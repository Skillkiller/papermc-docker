name: Version test
on:
  workflow_dispatch:
  push:

jobs:
  get-versions:
    name: Get all minecraft versions
    runs-on: ubuntu-latest
    outputs:
      mc-versions: ${{steps.get-mc-versions.outputs.mc-versions }}
      java-versions: ${{steps.get-mc-versions.outputs.java-versions }}
    steps:
      - name: Get minecraft versions
        id: get-mc-versions
        run: |
          PAPERMC_VERSIONS=$(curl -s -H 'accept: application/json' -H "User-Agent: ${GITHUB_REPOSITORY,,}" "https://fill.papermc.io/v3/projects/paper/versions")
          echo "$PAPERMC_VERSIONS"
          echo "mc-versions=$(echo "$PAPERMC_VERSIONS" | jq -c '[.versions[] | {MC_VERSION: .version.id, JAVA_VERSION: .version.java.version.minimum, STATUS: .version.support.status}]')" >> "$GITHUB_OUTPUT"
          echo "" >> "$GITHUB_OUTPUT"
          echo "java-versions=$(echo "$PAPERMC_VERSIONS" | jq -c '[.versions[].version.java.version.minimum] | sort | unique')" >> "$GITHUB_OUTPUT"
  build-images:
    name: Build docker images
    runs-on: ubuntu-latest
    needs: get-versions
    strategy:
      matrix:
        java-version: ${{ fromJson(needs.get-versions.outputs.java-versions) }}
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Lowercase repo name
        run: echo "REPO=${GITHUB_REPOSITORY,,}" >> ${GITHUB_ENV}

      - name: Build and export
        uses: docker/build-push-action@v6
        with:
          tags: ${{ env.REPO }}:jdk-${{ matrix.java-version }}
          build-args: MINEBASE_IMAGE=jdk-${{ matrix.java-version }}
          outputs: type=docker,dest=${{ runner.temp }}/papermc-jdk-${{ matrix.java-version }}.tar

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: papermc-jdk-${{ matrix.java-version }}.tar
          path: ${{ runner.temp }}/papermc-jdk-${{ matrix.java-version }}.tar
  produce-artifacts:
    runs-on: ubuntu-latest
    needs: [get-versions, build-images]
    strategy:
      fail-fast: false
      matrix:
        mc-version: ${{ fromJson(needs.get-versions.outputs.mc-versions) }}
    continue-on-error: true
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: papermc-jdk-${{ matrix.mc-version.JAVA_VERSION }}.tar
          path: ${{ runner.temp }}
      - name: Load image
        run: |
          docker load --input ${{ runner.temp }}/papermc-jdk-${{ matrix.mc-version.JAVA_VERSION }}.tar
          docker image ls -a
      - name: Lowercase repo name
        run: echo "REPO=${GITHUB_REPOSITORY,,}" >> ${GITHUB_ENV}
      - name: Start Minecraft server
        id: start-server
        env:
          MC_VERSION: ${{ matrix.mc-version.MC_VERSION }}
          JAVA_VERSION: ${{ matrix.mc-version.JAVA_VERSION }}
        run: |
          echo -e "enable-rcon=true\nrcon.password=$(openssl rand -hex 16)\nrcon.port=25575" > server.properties

          CONTAINER_ID=$(docker run -d \
            -e "VERSION=$MC_VERSION" \
            -e "JVM_PARAMS=" \
            -p "25565:25565" \
            -v "./server.properties:/etc/mcserver/locals/server.properties" \
            ${{ env.REPO }}:jdk-$JAVA_VERSION)

          echo "Container started: $CONTAINER_ID"
          echo "Waiting for startup log line..."

          TIMEOUT=120
          SECONDS_PASSED=0
          INTERVAL=1
          READY_LOG_ENTRY="Starting minecraft server version"

          while true; do
            # Prüfe, ob der Container überhaupt noch läuft
            CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' "$CONTAINER_ID" 2>/dev/null)

            if [[ "$CONTAINER_STATUS" != "running" ]]; then
              echo "::error::Container $CONTAINER_ID läuft nicht mehr (Status: $CONTAINER_STATUS)"
              docker logs "$CONTAINER_ID" 2>&1
              exit 1
            fi

            # Prüfe, ob die Log-Zeile vorkommt
            if docker logs "$CONTAINER_ID" 2>/dev/null | grep -q "$READY_LOG_ENTRY"; then
              echo "Server im Container $CONTAINER_ID ist bereit."
              break
            fi

            # Timeout prüfen
            if (( SECONDS_PASSED >= TIMEOUT )); then
              echo "::error::Timeout nach $TIMEOUT Sekunden - Server wurde nicht bereit."
              docker logs "$CONTAINER_ID" 2>&1
              exit 1
            fi

            sleep $INTERVAL
            ((SECONDS_PASSED+=INTERVAL))
          done

          echo "Server started successfully."

          SEARCH="Starting minecraft server version"
          LOG_OUTPUT=$(docker logs "$CONTAINER_ID" 2>&1)
          MATCHES=$(echo "$LOG_OUTPUT" | grep "$SEARCH" || true)
          MATCH_COUNT=$(echo "$MATCHES" | wc -l)

          if [[ "$MATCH_COUNT" -ne 1 ]]; then
            echo "::error::Expected exactly 1 occurrence of '$SEARCH', but found $MATCH_COUNT"
            exit 1
          fi

          MATCHED_LINE="$MATCHES"
          echo "Log line found: $MATCHED_LINE"

          EXPECTED="Starting minecraft server version $MC_VERSION"
          ACTUAL="$MATCHED_LINE"

          echo "Expected: $EXPECTED"
          echo "Actual:   $ACTUAL"

          echo "log-line=$ACTUAL" >> $GITHUB_OUTPUT

          if [[ "$ACTUAL" == *"$EXPECTED" ]]; then
            echo "✅ Expected Minecraft server version started."
            echo "status=✅" >> $GITHUB_OUTPUT
          else
            echo "::error::Unexpected Minecraft server version started."
            echo "status=❌" >> $GITHUB_OUTPUT
            exit 2
          fi
        ## Write for matrix outputs workaround 
      - uses: cloudposse/github-action-matrix-outputs-write@v1
        if: always()
        id: out
        with:
          matrix-step-name: ${{ github.job }}
          matrix-key: ${{ matrix.mc-version.MC_VERSION }}
          outputs: |-
            status: ${{ steps.start-server.outputs.status }}

  ## Read matrix outputs 
  read:
    runs-on: ubuntu-latest
    needs: [produce-artifacts]
    steps:
      - uses: cloudposse/github-action-matrix-outputs-read@v1
        id: read
        with:
          matrix-step-name: produce-artifacts
      - run: echo "${{ steps.read.outputs.result }}"

    outputs:
      result: "${{ steps.read.outputs.result }}"